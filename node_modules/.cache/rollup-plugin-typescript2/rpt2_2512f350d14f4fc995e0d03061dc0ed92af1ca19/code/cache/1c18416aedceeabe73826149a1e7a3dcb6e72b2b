{"code":"import { __assign, __asyncValues, __awaiter, __generator } from \"tslib\";\r\nimport EventEmitter from \"../EventEmitter\";\r\n/**\r\n * 格式化性能记录,小数位数保留最多两位,等于0的字段不传输,标记为undefined\r\n */\r\nexport function normalizePerformanceRecord(e) {\r\n    Object.keys(e).forEach(function (p) {\r\n        var v = e[p];\r\n        if (typeof v === 'number')\r\n            e[p] = v === 0 ? undefined : parseFloat(v.toFixed(2));\r\n    });\r\n    return e;\r\n}\r\n/*\r\n随机uuid\r\n*/\r\nexport function getUUid() {\r\n    return new Date().getTime();\r\n}\r\n/*\r\nmap\r\n*/\r\nvar arrayMap = Array.prototype.map || function polyfillMap(fn) {\r\n    var result = [];\r\n    for (var i = 0; i < this.length; i += 1) {\r\n        result.push(fn(this[i], i, this));\r\n    }\r\n    return result;\r\n};\r\nexport function map(arr, fn) {\r\n    return arrayMap.call(arr, fn);\r\n}\r\n/**\r\n * filter方法\r\n * @param {Array} arr 源数组\r\n * @param {Function} fn 条件函数\r\n * @returns\r\n */\r\nvar arrayFilter = Array.prototype.filter || function filterPolyfill(fn) {\r\n    var result = [];\r\n    for (var i = 0; i < this.length; i += 1) {\r\n        if (fn(this[i], i, this)) {\r\n            result.push(this[i]);\r\n        }\r\n    }\r\n    return result;\r\n};\r\nexport function filter(arr, fn) {\r\n    return arrayFilter.call(arr, fn);\r\n}\r\n/*\r\nPerformanceObserver 获取相关信息\r\n*/\r\nexport function createObserver(params, addEmit, values) {\r\n    var _this = this;\r\n    var observePerformance = {};\r\n    return new Promise(function (resolve, reject) {\r\n        var observer = new PerformanceObserver(function (list) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _a, _b, _c, entry, e_1_1, lastValue;\r\n            var _d, e_1, _e, _f;\r\n            return __generator(this, function (_g) {\r\n                switch (_g.label) {\r\n                    case 0:\r\n                        _g.trys.push([0, 5, 6, 11]);\r\n                        _a = true, _b = __asyncValues(list.getEntries());\r\n                        _g.label = 1;\r\n                    case 1: return [4 /*yield*/, _b.next()];\r\n                    case 2:\r\n                        if (!(_c = _g.sent(), _d = _c.done, !_d)) return [3 /*break*/, 4];\r\n                        _f = _c.value;\r\n                        _a = false;\r\n                        try {\r\n                            entry = _f;\r\n                            if (entry.entryType === 'navigation') {\r\n                                observePerformance[entry.entryType] = __assign({}, entry.toJSON());\r\n                            }\r\n                            else if (entry.entryType === 'resource') {\r\n                                if (entry.initiatorType === \"xmlhttprequest\") {\r\n                                    // api 请求\r\n                                    if (entry.name.includes(\"api/\")) {\r\n                                        observePerformance.resource = observePerformance.resource || {};\r\n                                        observePerformance.resource[entry.name] = __assign({}, entry.toJSON());\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                observePerformance[entry.name] = {\r\n                                    name: entry.name,\r\n                                    entryType: entry.entryType,\r\n                                    startTime: entry.startTime,\r\n                                    duration: entry.duration\r\n                                };\r\n                            }\r\n                        }\r\n                        finally {\r\n                            _a = true;\r\n                        }\r\n                        _g.label = 3;\r\n                    case 3: return [3 /*break*/, 1];\r\n                    case 4: return [3 /*break*/, 11];\r\n                    case 5:\r\n                        e_1_1 = _g.sent();\r\n                        e_1 = { error: e_1_1 };\r\n                        return [3 /*break*/, 11];\r\n                    case 6:\r\n                        _g.trys.push([6, , 9, 10]);\r\n                        if (!(!_a && !_d && (_e = _b.return))) return [3 /*break*/, 8];\r\n                        return [4 /*yield*/, _e.call(_b)];\r\n                    case 7:\r\n                        _g.sent();\r\n                        _g.label = 8;\r\n                    case 8: return [3 /*break*/, 10];\r\n                    case 9:\r\n                        if (e_1) throw e_1.error;\r\n                        return [7 /*endfinally*/];\r\n                    case 10: return [7 /*endfinally*/];\r\n                    case 11:\r\n                        resolve(observePerformance);\r\n                        lastValue = values;\r\n                        if (addEmit && observePerformance[addEmit] && JSON.stringify(lastValue) !== JSON.stringify(observePerformance[addEmit])) {\r\n                            lastValue = __assign({}, observePerformance[addEmit]);\r\n                            console.log('---343245', observePerformance[addEmit]);\r\n                            EventEmitter.emit(addEmit, observePerformance[addEmit]);\r\n                        }\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); });\r\n        observer.observe(params);\r\n    });\r\n}\r\nexport var sendBeacon = navigator.sendBeacon\r\n    ? function (url, data) {\r\n        if (data)\r\n            navigator.sendBeacon(url, JSON.stringify(data));\r\n    }\r\n    : function (url, data) {\r\n        // 传统方式传递参数\r\n        var beacon = new Image();\r\n        beacon.src = \"\".concat(url, \"?v=\").concat(encodeURIComponent(JSON.stringify(data)));\r\n    };\r\n/**\r\n* 可以理解为异步执行\r\n* requestIdleCallback 是浏览器空闲时会自动执行内部函数\r\n* requestAnimationFrame 是浏览器必须执行的\r\n* 关于 requestIdleCallback 和  requestAnimationFrame 可以参考 https://www.cnblogs.com/cangqinglang/p/13877078.html\r\n*/\r\nexport var nextTime = window.requestIdleCallback || window.requestAnimationFrame || (function (callback) { return setTimeout(callback, 17); });\r\n/*\r\n之前看过一个段子，两个人一同去网吧包夜，一个人玩了一晚上的扫雷，而另一个则看着他玩了一晚上的扫雷。\r\n咋一听来，这个游戏是在嘲讽\"扫雷\"游戏的无聊，但反过来想不也正说明\"扫雷\"很有魅力。\r\n扫雷就像是一道数学推理题，游戏的乐趣就在于思考和推理，稳中求快，\r\n*/\r\n// 扫雷这题的目标就是全面皆玩，不管通不通关，大家看到这道题的第一眼就知道怎么玩了，为了增加难度，也是\r\n//闯关的难点 估计就是雷比较多了，150个雷，想要通关还是需要点技巧的，稳重求快，高效的做对的事，才能\r\n","references":["/Users/jinmingliu/code/my-track/lib/EventEmitter.ts"]}
